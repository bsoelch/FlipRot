#_ Stack implementation at the upper end of RAM
Memory layout: 
0xffffff-0xfffffd addresses for tmp-vars
0xfffffc-0xfffff1 addresses additional register-like values
0xfffff0 stack-pointer
0xffffef-0xf00000 stack 
_#
#ifndef $$stack$$
#_ skip code in file _#
$$stack$$ swap 1 jumpif

#_ addresses for temporary values within macros/procedures, 
these address may be overwritten by any macro _#
#def tmp_ret  0xffffffffffff #enddef
#def tmp_loop 0xfffffffffffe #enddef
#_ addresses for immediate values 
this addresses may be saved on/restored from the stack on procedure calls
_#
#def varD 0xfffffffffffd #enddef
#def varC 0xfffffffffffc #enddef
#def varB 0xfffffffffffb #enddef
#def varA 0xfffffffffffa #enddef
#def var9 0xfffffffffff9 #enddef
#def var8 0xfffffffffff8 #enddef
#def var7 0xfffffffffff7 #enddef
#def var6 0xfffffffffff6 #enddef
#def var5 0xfffffffffff5 #enddef
#def var4 0xfffffffffff4 #enddef
#def var3 0xfffffffffff3 #enddef
#def var2 0xfffffffffff2 #enddef
#def var1 0xfffffffffff1 #enddef

#_ points to address above the top of the stack _#
#def stack_prt 0xfffffffffff0 #enddef
#_ resets the stack, 
this macro should be used before the first call of push _#
#def stack_reset
stack_prt swap 0xffffffffffef store
#enddef

#_ increments the stack_prt
	modifies tmp_loop, tmp_ret 
_#
#label $$stack$$.inc
#undef $$stack$$.inc.loop
#undef $$stack$$.inc.break
#undef $$stack$$.inc.reset
tmp_ret swap store #_ save return address _#
#_ set tmp_loop (loop-count) to unary 20 _#
tmp_loop swap 0xfffff store 
#label $$stack$$.inc.loop
stack_prt swap stack_prt load flip store #_ flip lowest bit of stack_prt _#
swap $$stack$$.inc.break swap
jumpif
swap stack_prt swap rot store
tmp_loop swap tmp_loop load rot store
swap $$stack$$.inc.loop swap
jumpif #_ jump to loop if rotation count not yet reached _#
swap $$stack$$.inc.reset swap 
1 jumpif #_ jump to reset _#
#label $$stack$$.inc.break
stack_prt swap stack_prt load rot store
tmp_loop swap tmp_loop load rot store
swap $$stack$$.inc.break swap
jumpif #_ jump to break if rotation count not yet reached _#
swap $$stack$$.inc.reset swap 
1 jumpif #_ jump to reset _#
#label $$stack$$.inc.reset
stack_prt swap stack_prt load
#_ rotate by 64-20 _#
rot rot rot rot rot rot rot rot rot rot rot rot rot rot rot rot 
rot rot rot rot rot rot rot rot rot rot rot rot rot rot rot rot 
rot rot rot rot rot rot rot rot rot rot rot rot   
store 
#undef $$stack$$.inc.loop
#undef $$stack$$.inc.break
#undef $$stack$$.inc.reset
tmp_ret load swap #_ load return address _#
1 jumpif
#_ end of $$stack$$.inc _#

#_ decrements the stack_prt, 
	modifies tmp_loop, tmp_ret 
_#
#label $$stack$$.dec
#undef $$stack$$.dec.loop1
#undef $$stack$$.dec.break
#undef $$stack$$.dec.loop2
#undef $$stack$$.dec.reset
tmp_ret swap store #_ save return address _#
#_ set tmp_loop (loop-count) to unary 20 _#
tmp_loop swap 0xfffff store 
#label $$stack$$.dec.loop1
stack_prt swap stack_prt load
swap $$stack$$.dec.break swap
jumpif
swap stack_prt swap flip rot store #_ flip lowest bit of stack_prt _#
tmp_loop swap tmp_loop load rot store
swap $$stack$$.dec.loop1 swap 
jumpif #_ jump to loop1 if rotation count not yet reached _#
swap $$stack$$.dec.reset swap 
1 jumpif #_ jump to reset _#
#label $$stack$$.dec.break
swap stack_prt swap flip store
#label $$stack$$.dec.loop2
stack_prt swap stack_prt load rot store
tmp_loop swap tmp_loop load rot store
swap $$stack$$.dec.loop2 swap 
jumpif #_ jump to loop2 if rotation count not yet reached _#
#label $$stack$$.dec.reset
stack_prt swap stack_prt load
#_ rotate by 64-20 _#
rot rot rot rot rot rot rot rot rot rot rot rot rot rot rot rot 
rot rot rot rot rot rot rot rot rot rot rot rot rot rot rot rot 
rot rot rot rot rot rot rot rot rot rot rot rot   
store 
#undef $$stack$$.dec.loop1
#undef $$stack$$.dec.break
#undef $$stack$$.dec.loop2
#undef $$stack$$.dec.reset
tmp_ret load swap #_ load return address _#
1 jumpif
#_ end of $$stack$$.dec _#


#def push 
#_ needs macro in macro 
#ifndef $$stack$$.stackInitialized
stack_reset
#def $$stack$$.stackInitialized #enddef
#endif
_#

swap stack_prt load swap store #_ store value at top of stack _#
$$stack$$.dec swap 
1 jumpif #_ decrement the stack pointer _#
#enddef

#def pop 
#_ needs macro in macro 
#ifndef $$stack$$.stackInitialized
stack_reset
#def $$stack$$.stackInitialized #enddef
#endif 
_#
$$stack$$.inc swap 
1 jumpif #_ increment the stack_pointer _#
stack_prt load load #_ load value at top of stack _#
#enddef

#_ label for skipping code in file _#
#label $$stack$$
#endif